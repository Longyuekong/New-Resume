I"J<h1 id="前言"><strong>前言</strong></h1>

<p>对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，对自己有一定的启发思考,对缺漏之处进行弥补，对 Vue 有更好的掌握。</p>

<h2 id="1vue-的父组件和子组件生命周期钩子函数执行顺序"><strong>1、Vue 的父组件和子组件生命周期钩子函数执行顺序？</strong></h2>

<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>

<ul>
  <li>
    <p>加载渲染过程</p>

    <p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
  </li>
  <li>
    <p>子组件更新过程</p>

    <p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
  </li>
  <li>
    <p>父组件更新过程</p>

    <p>父 beforeUpdate -&gt; 父 updated</p>
  </li>
  <li>
    <p>销毁过程</p>

    <p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
  </li>
</ul>

<h2 id="2在哪个生命周期内调用异步请求在什么阶段才能访问操作dom">2、<strong>在哪个生命周期内调用异步请求？</strong>在什么阶段才能访问操作DOM？<em>**</em></h2>

<p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>

<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>

<p>有两种常见的试图改变一个 prop 的情形 :</p>

<ul>
  <li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong> 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="ss">props: </span><span class="p">[</span><span class="s1">'initialCounter'</span><span class="p">],</span>
<span class="ss">data: </span><span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="ss">counter: </span><span class="n">this</span><span class="p">.</span><span class="nf">initialCounter</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong> 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="ss">props: </span><span class="p">[</span><span class="s1">'size'</span><span class="p">],</span>
<span class="ss">computed: </span><span class="p">{</span>
  <span class="ss">normalizedSize: </span><span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="p">.</span><span class="nf">size</span><span class="p">.</span><span class="nf">trim</span><span class="p">().</span><span class="nf">toLowerCase</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h2 id="3computed-和-watch-的区别和运用的场景">3、computed 和 watch 的区别和运用的场景？</h2>

<p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>

<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>

<p><strong>运用场景：</strong></p>

<ul>
  <li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
  <li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>

<h2 id="4直接给一个数组项赋值vue-能检测到变化吗">4、直接给一个数组项赋值，Vue 能检测到变化吗？</h2>

<p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>

<ul>
  <li>当你利用索引直接设置一个数组项时，例如：<code class="highlighter-rouge">vm.items[indexOfItem] = newValue</code></li>
  <li>当你修改数组的长度时，例如：<code class="highlighter-rouge">vm.items.length = newLength</code></li>
</ul>

<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="sr">//</span> <span class="no">Vue</span><span class="p">.</span><span class="nf">set</span>
<span class="no">Vue</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="n">vm</span><span class="p">.</span><span class="nf">items</span><span class="p">,</span> <span class="n">indexOfItem</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span> 
<span class="sr">//</span> <span class="n">vm</span><span class="o">.</span><span class="vg">$set</span>
<span class="n">vm</span><span class="o">.</span><span class="vg">$set</span><span class="p">(</span><span class="n">vm</span><span class="p">.</span><span class="nf">items</span><span class="p">,</span> <span class="n">indexOfItem</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span>
<span class="sr">//</span> <span class="no">Array</span><span class="p">.</span><span class="nf">prototype</span><span class="p">.</span><span class="nf">splice</span>
<span class="n">vm</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="n">indexOfItem</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">newValue</span><span class="p">)</span></code></pre></figure>

<p>为了解决第二个问题，Vue 提供了以下操作方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Array.prototype.splice
vm.items.splice(newLength)
</code></pre></div></div>

<h2 id="5使用过-vue-ssr-吗说说-ssr"><strong>5、使用过 Vue SSR 吗？说说 SSR？</strong></h2>

<blockquote>
  <p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>

  <p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>

</blockquote>

<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>

<p><strong>（1）服务端渲染的优点：</strong></p>

<ul>
  <li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
  <li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>

<p><strong>（2) 服务端渲染的缺点：</strong></p>

<ul>
  <li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
  <li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>

<h2 id="6组件中-data-为什么是一个函数">6、组件中 data 为什么是一个函数？</h2>

<blockquote>
  <p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="sr">//</span> <span class="n">data</span>
<span class="n">data</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">{</span>
<span class="ss">message: </span><span class="s2">"子组件"</span><span class="p">,</span>
<span class="n">childName</span><span class="ss">:this</span><span class="p">.</span><span class="nf">name</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="sr">//</span> <span class="n">new</span> <span class="no">Vue</span>
<span class="n">new</span> <span class="no">Vue</span><span class="p">({</span>
<span class="ss">el: </span><span class="s1">'#app'</span><span class="p">,</span>
<span class="n">router</span><span class="p">,</span>
<span class="ss">template: </span><span class="s1">'&lt;App/&gt;'</span><span class="p">,</span>
<span class="ss">components: </span><span class="p">{</span><span class="no">App</span><span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>

<h2 id="7vue-router-路由模式有几种以及-hash-和-history-路由模式实现的原理"><strong>7、vue-router 路由模式有几种？</strong>以及 hash 和 history 路由模式实现的原理</h2>

<p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="s1">'history'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">HTML5History</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">)</span>
<span class="k">break</span>
<span class="k">case</span> <span class="s1">'hash'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">HashHistory</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">,</span> <span class="n">this</span><span class="p">.</span><span class="nf">fallback</span><span class="p">)</span>
<span class="k">break</span>
<span class="k">case</span> <span class="s1">'abstract'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">AbstractHistory</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">)</span>
<span class="k">break</span>
<span class="ss">default:
</span><span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="nf">env</span><span class="o">.</span><span class="no">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
<span class="n">assert</span><span class="p">(</span><span class="kp">false</span><span class="p">,</span> <span class="sb">`invalid mode: ${mode}`</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>其中，3 种路由模式的说明如下：</p>

<ul>
  <li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
  <li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
  <li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>

<p><strong>（1）hash 模式的实现原理</strong></p>

<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">https</span><span class="ss">:/</span><span class="o">/</span><span class="n">www</span><span class="p">.</span><span class="nf">word</span><span class="p">.</span><span class="nf">com</span><span class="c1">#search</span></code></pre></figure>

<p>hash 路由模式的实现主要是基于下面几个特性：</p>

<ul>
  <li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
  <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
  <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
  <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>

<p><strong>（2）history 模式的实现原理</strong></p>

<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">window</span><span class="p">.</span><span class="nf">history</span><span class="p">.</span><span class="nf">pushState</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="n">window</span><span class="p">.</span><span class="nf">history</span><span class="p">.</span><span class="nf">replaceState</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span></code></pre></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>

<ul>
  <li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
  <li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
  <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>

<h2 id="8虚拟-dom-实现原理它的优缺点"><strong>8、虚拟 DOM 实现原理？</strong>它的优缺点？</h2>

<p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>

<ul>
  <li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
  <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
  <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>

<p><strong>优点：</strong></p>

<ul>
  <li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
  <li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
  <li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>

<p><strong>缺点:</strong></p>

<ul>
  <li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>

:ET