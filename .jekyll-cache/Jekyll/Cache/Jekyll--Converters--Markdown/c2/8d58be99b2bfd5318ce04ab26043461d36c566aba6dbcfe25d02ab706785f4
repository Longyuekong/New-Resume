I"?<h2 id="前言">前言</h2>

<p>对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，对自己有一定的启发思考,对缺漏之处进行弥补，对 Vue 有更好的掌握。</p>

<h3 id="1说说你对-spa-单页面的理解它的优缺点分别是什么"><strong>1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</strong></h3>

<p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>

<p><strong>优点：</strong></p>

<ul>
  <li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
  <li>基于上面一点，SPA 相对对服务器压力小；</li>
  <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>

<p><strong>缺点：</strong></p>

<ul>
  <li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
  <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
  <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>

<h2 id="2v-show-与-v-if-有什么区别">2、v-show 与 v-if 有什么区别？</h2>

<p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>

<p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换</p>

<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>

<h2 id="3怎样理解-vue-的单向数据流">3、怎样理解 Vue 的单向数据流？</h2>

<p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>

<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p>

<p>有两种常见的试图改变一个 prop 的情形 :</p>

<ul>
  <li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong> 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="ss">props: </span><span class="p">[</span><span class="s1">'initialCounter'</span><span class="p">],</span>
<span class="ss">data: </span><span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="ss">counter: </span><span class="n">this</span><span class="p">.</span><span class="nf">initialCounter</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong> 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
</code></pre></div></div>

<h2 id="4computed-和-watch-的区别和运用的场景">4、computed 和 watch 的区别和运用的场景？</h2>

<p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>

<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>

<p><strong>运用场景：</strong></p>

<ul>
  <li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
  <li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>

<h2 id="5直接给一个数组项赋值vue-能检测到变化吗">5、直接给一个数组项赋值，Vue 能检测到变化吗？</h2>

<p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p>

<ul>
  <li>当你利用索引直接设置一个数组项时，例如：<code class="highlighter-rouge">vm.items[indexOfItem] = newValue</code></li>
  <li>当你修改数组的长度时，例如：<code class="highlighter-rouge">vm.items.length = newLength</code></li>
</ul>

<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Vue.set
Vue.set(vm.items, indexOfItem, newValue) 
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
</code></pre></div></div>

<p>为了解决第二个问题，Vue 提供了以下操作方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Array.prototype.splice
vm.items.splice(newLength)
</code></pre></div></div>

<h2 id="6使用过-vue-ssr-吗说说-ssr"><strong>6、使用过 Vue SSR 吗？说说 SSR？</strong></h2>

<blockquote>
  <p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p>

  <p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>

</blockquote>

<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>

<p><strong>（1）服务端渲染的优点：</strong></p>

<ul>
  <li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
  <li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>

<p><strong>（2) 服务端渲染的缺点：</strong></p>

<ul>
  <li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
  <li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>

<h2 id="7组件中-data-为什么是一个函数">7、组件中 data 为什么是一个函数？</h2>

<blockquote>
  <p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="sr">//</span> <span class="n">data</span>
<span class="n">data</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">{</span>
<span class="ss">message: </span><span class="s2">"子组件"</span><span class="p">,</span>
<span class="n">childName</span><span class="ss">:this</span><span class="p">.</span><span class="nf">name</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="sr">//</span> <span class="n">new</span> <span class="no">Vue</span>
<span class="n">new</span> <span class="no">Vue</span><span class="p">({</span>
<span class="ss">el: </span><span class="s1">'#app'</span><span class="p">,</span>
<span class="n">router</span><span class="p">,</span>
<span class="ss">template: </span><span class="s1">'&lt;App/&gt;'</span><span class="p">,</span>
<span class="ss">components: </span><span class="p">{</span><span class="no">App</span><span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>

<h2 id="8vue-router-路由模式有几种以及-hash-和-history-路由模式实现的原理"><strong>8、vue-router 路由模式有几种？</strong>以及 hash 和 history 路由模式实现的原理</h2>

<p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="s1">'history'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">HTML5History</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">)</span>
<span class="k">break</span>
<span class="k">case</span> <span class="s1">'hash'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">HashHistory</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">,</span> <span class="n">this</span><span class="p">.</span><span class="nf">fallback</span><span class="p">)</span>
<span class="k">break</span>
<span class="k">case</span> <span class="s1">'abstract'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">AbstractHistory</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">)</span>
<span class="k">break</span>
<span class="ss">default:
</span><span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="nf">env</span><span class="o">.</span><span class="no">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
<span class="n">assert</span><span class="p">(</span><span class="kp">false</span><span class="p">,</span> <span class="sb">`invalid mode: ${mode}`</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>其中，3 种路由模式的说明如下：</p>

<ul>
  <li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
  <li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
  <li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>

<p><strong>（1）hash 模式的实现原理</strong></p>

<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://www.word.com#search
</code></pre></div></div>

<p>hash 路由模式的实现主要是基于下面几个特性：</p>

<ul>
  <li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
  <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
  <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
  <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>

<p><strong>（2）history 模式的实现原理</strong></p>

<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">window</span><span class="p">.</span><span class="nf">history</span><span class="p">.</span><span class="nf">pushState</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="n">window</span><span class="p">.</span><span class="nf">history</span><span class="p">.</span><span class="nf">replaceState</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span></code></pre></figure>
:ET