I"F<h1 id="前言"><strong>前言</strong></h1>

<p>对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，对自己有一定的启发思考,对缺漏之处进行弥补，对 Vue 有更好的掌握。</p>

<h2 id="1vue-的父组件和子组件生命周期钩子函数执行顺序"><strong>1、Vue 的父组件和子组件生命周期钩子函数执行顺序？</strong></h2>

<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>

<ul>
  <li>
    <p>加载渲染过程</p>

    <p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
  </li>
  <li>
    <p>子组件更新过程</p>

    <p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
  </li>
  <li>
    <p>父组件更新过程</p>

    <p>父 beforeUpdate -&gt; 父 updated</p>
  </li>
  <li>
    <p>销毁过程</p>

    <p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
  </li>
</ul>

<h2 id="2在哪个生命周期内调用异步请求在什么阶段才能访问操作dom">2、<strong>在哪个生命周期内调用异步请求？</strong>在什么阶段才能访问操作DOM？</h2>

<p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>

<ul>
  <li>能更快获取到服务端数据，减少页面 loading 时间；</li>
  <li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>

<p>在钩子函数 <strong>mounted</strong> 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 <strong>mounted</strong> 中可以访问操作 DOM。</p>

<h2 id="3谈谈你对-keep-alive-的了解">3、<strong>谈谈你对 keep-alive 的了解？</strong></h2>

<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>

<ul>
  <li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
  <li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li>
  <li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>

<h2 id="4vue-组件间通信有哪几种方式">4、<strong>Vue 组件间通信有哪几种方式？</strong></h2>

<p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p>

<p><strong>（1）props / $emit 适用 父子组件通信</strong></p>

<p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p>

<p><strong>（2）ref 与 $parent / $children 适用 父子组件通信</strong></p>

<ul>
  <li><code class="highlighter-rouge">ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
  <li><code class="highlighter-rouge">$parent</code> / <code class="highlighter-rouge">$children</code>：访问父 / 子实例</li>
</ul>

<p><strong>（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</strong></p>

<p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p>

<p><strong>（4）$attrs/$listeners 适用于 隔代组件通信</strong></p>

<ul>
  <li><code class="highlighter-rouge">$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code class="highlighter-rouge">v-bind="$attrs"</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li>
  <li><code class="highlighter-rouge">$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 <code class="highlighter-rouge">v-on="$listeners"</code> 传入内部组件</li>
</ul>

<p><strong>（5）provide / inject 适用于 隔代组件通信</strong></p>

<p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>

<p><strong>（6）Vuex 适用于 父子、隔代、兄弟组件通信</strong></p>

<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>

<p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>

<p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p>

<p>主要包括以下几个模块：</p>

<ul>
  <li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li>
  <li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li>
  <li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li>
  <li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li>
  <li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li>
</ul>

<h2 id="5vue-是如何实现数据双向绑定的"><strong>5、</strong>Vue 是如何实现数据双向绑定的？<em>**</em></h2>

<blockquote>

</blockquote>

<p><strong>服务端渲染 SSR 的优缺点如下：</strong></p>

<p><strong>（1）服务端渲染的优点：</strong></p>

<ul>
  <li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
  <li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>

<p><strong>（2) 服务端渲染的缺点：</strong></p>

<ul>
  <li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
  <li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>

<h2 id="6组件中-data-为什么是一个函数">6、组件中 data 为什么是一个函数？</h2>

<blockquote>
  <p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="sr">//</span> <span class="n">data</span>
<span class="n">data</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">{</span>
<span class="ss">message: </span><span class="s2">"子组件"</span><span class="p">,</span>
<span class="n">childName</span><span class="ss">:this</span><span class="p">.</span><span class="nf">name</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="sr">//</span> <span class="n">new</span> <span class="no">Vue</span>
<span class="n">new</span> <span class="no">Vue</span><span class="p">({</span>
<span class="ss">el: </span><span class="s1">'#app'</span><span class="p">,</span>
<span class="n">router</span><span class="p">,</span>
<span class="ss">template: </span><span class="s1">'&lt;App/&gt;'</span><span class="p">,</span>
<span class="ss">components: </span><span class="p">{</span><span class="no">App</span><span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>

<h2 id="7vue-router-路由模式有几种以及-hash-和-history-路由模式实现的原理"><strong>7、vue-router 路由模式有几种？</strong>以及 hash 和 history 路由模式实现的原理</h2>

<p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="s1">'history'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">HTML5History</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">)</span>
<span class="k">break</span>
<span class="k">case</span> <span class="s1">'hash'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">HashHistory</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">,</span> <span class="n">this</span><span class="p">.</span><span class="nf">fallback</span><span class="p">)</span>
<span class="k">break</span>
<span class="k">case</span> <span class="s1">'abstract'</span><span class="p">:</span>
<span class="n">this</span><span class="p">.</span><span class="nf">history</span> <span class="o">=</span> <span class="n">new</span> <span class="no">AbstractHistory</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">options</span><span class="p">.</span><span class="nf">base</span><span class="p">)</span>
<span class="k">break</span>
<span class="ss">default:
</span><span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="nf">env</span><span class="o">.</span><span class="no">NODE_ENV</span> <span class="o">!==</span> <span class="s1">'production'</span><span class="p">)</span> <span class="p">{</span>
<span class="n">assert</span><span class="p">(</span><span class="kp">false</span><span class="p">,</span> <span class="sb">`invalid mode: ${mode}`</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>其中，3 种路由模式的说明如下：</p>

<ul>
  <li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li>
  <li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li>
  <li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li>
</ul>

<p><strong>（1）hash 模式的实现原理</strong></p>

<p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">https</span><span class="ss">:/</span><span class="o">/</span><span class="n">www</span><span class="p">.</span><span class="nf">word</span><span class="p">.</span><span class="nf">com</span><span class="c1">#search</span></code></pre></figure>

<p>hash 路由模式的实现主要是基于下面几个特性：</p>

<ul>
  <li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
  <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
  <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
  <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li>
</ul>

<p><strong>（2）history 模式的实现原理</strong></p>

<p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">window</span><span class="p">.</span><span class="nf">history</span><span class="p">.</span><span class="nf">pushState</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="n">window</span><span class="p">.</span><span class="nf">history</span><span class="p">.</span><span class="nf">replaceState</span><span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span></code></pre></figure>

<p>history 路由模式的实现主要基于存在下面几个特性：</p>

<ul>
  <li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
  <li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
  <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>

<h2 id="8虚拟-dom-实现原理它的优缺点"><strong>8、虚拟 DOM 实现原理？</strong>它的优缺点？</h2>

<p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>

<ul>
  <li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
  <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
  <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>

<p><strong>优点：</strong></p>

<ul>
  <li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
  <li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
  <li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>

<p><strong>缺点:</strong></p>

<ul>
  <li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>

:ET